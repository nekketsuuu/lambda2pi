// This parser package provides lexer and parser of lambda calculus.
//
// Note that parser.go is auto-generated from parser.y, using goyacc.
// If you want to re-generate parser.go, run
//
//     $ go generate
//
// or use goyacc directly (please look at generate.go).
//
// If you want to know about <prefix>Lexer and <prefix>Parser, read the godoc of goyacc.
//
// References:
//
//  * golang.org/x/tools/cmd/goyacc/testdata/expr/expr.y
//
//  * http://qiita.com/draftcode/items/c9f2422fca14133c7f6a
//
//  * github.com/golang/go/src/go/parser/parser_test.go
//
// TODO(nekketsuuu): Add a location info into yyLex, and print a error with the location.
//
// TODO(nekketsuuu): Use buffer instead of naive []bytes.
//
package parser

import (
	"bytes"
	"errors"
	"log"
	"unicode"
	"unicode/utf8"

	"github.com/nekketsuuu/lambda2pi"
)

// The parser expects the lexer to return 0 on EOF.
const eof = 0

// The type of lexer, <prefix>Lex, is used by parser.
//
// In fact, it is OK to use any type which provides the methods
// Lex(*<prefix>SymType) int and Error(string).
type yyLex struct {
	line []byte           // the source code
	peek rune             // the next Unicode character
	term lambda2pi.Lambda // parsing result
	err  error
}

// The parser calls this method to get each new token.
//
// The definition of each terminals are automatically generated by yacc.
//
// The type of argument, <prefix>SymType, is a type of symbols,
// which is written in %union section of parser.y and is auto-generated by yacc.
//
func (x *yyLex) Lex(yylval *yySymType) int {
	for {
		c := x.next()
		switch c {
		case eof:
			return eof
		case '(':
			return LPAR
		case ')':
			return RPAR
		case '\u005c', '\u00a5', 'Î»': // backslash, yen mark (for Mac), and small lambda
			return LAMBDA
		case '.':
			return DOT
		default:
			if IsBasicLatinAlphabet(c) {
				return x.ident(c, yylval)
			} else if !unicode.IsSpace(c) {
				log.Printf("lexer: skip unrecognized character %q\n", c)
			}
		}
	}
}

// Lex a identifier.
func (x *yyLex) ident(c rune, yylval *yySymType) int {
	add := func(b *bytes.Buffer, c rune) {
		if _, err := b.WriteRune(c); err != nil {
			log.Fatalf("lexer: WriteRune failed. %s", err)
		}
	}
	var b bytes.Buffer
	add(&b, c)
ConsumeAlphas:
	for {
		c = x.next()
		if IsBasicLatinAlphabet(c) || IsBasicDigit(c) {
			add(&b, c)
		} else {
			break ConsumeAlphas
		}
	}
	if c != eof {
		x.peek = c
	}
	yylval.ident = lambda2pi.LambdaIdent(b.String())
	return IDENT
}

// Return the next rune for the lexer.
func (x *yyLex) next() rune {
	if x.peek != eof {
		r := x.peek
		x.peek = eof
		return r
	}
	if len(x.line) == 0 {
		return eof
	}
	c, size := utf8.DecodeRune(x.line)
	x.line = x.line[size:]
	if c == utf8.RuneError && size == 1 {
		log.Println("lexer: skip invalid utf8")
		return x.next()
	}
	return c
}

// The parser calls this method on a parse error.
//
// TODO(nekketsuuu): delete log
//
func (x *yyLex) Error(s string) {
	log.Printf("parse error: %s\n", s)
	x.err = errors.New(s)
}

// IsBasicLatinAlphabet reports whether the rune is a letter of [A-Za-z].
func IsBasicLatinAlphabet(r rune) bool {
	return (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z')
}

// IsBasicDigit reports whether the rune is a letter of [0-9].
func IsBasicDigit(r rune) bool {
	return r >= '0' && r <= '9'
}
